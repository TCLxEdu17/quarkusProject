<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/multitenant/repository/ProcessedMessageRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/multitenant/repository/ProcessedMessageRepository.java" />
              <option name="originalContent" value="package com.example.multitenant.repository;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import jakarta.enterprise.context.ApplicationScoped;&#10;import jakarta.inject.Inject;&#10;import org.hibernate.Session;&#10;import org.hibernate.SessionFactory;&#10;import org.hibernate.Transaction;&#10;import org.jboss.logging.Logger;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Repositório que usa SessionFactory diretamente para abrir sessões&#10; * com tenant explícito via withOptions().tenantIdentifier().&#10; * Isso evita depender do ThreadLocal + @Transactional + TenantResolver,&#10; * que falha em contextos multi-thread com executor pools.&#10; */&#10;@ApplicationScoped&#10;public class ProcessedMessageRepository {&#10;&#10;    private static final Logger LOG = Logger.getLogger(ProcessedMessageRepository.class);&#10;&#10;    @Inject&#10;    SessionFactory sessionFactory;&#10;&#10;    public ProcessedMessage save(ProcessedMessage message) {&#10;        String tenant = message.getTenantId();&#10;        LOG.infov(&quot;Saving message [{0}] for tenant [{1}] on thread [{2}]&quot;,&#10;                message.getMessageId(), tenant, Thread.currentThread().getName());&#10;&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenant).openSession()) {&#10;            Transaction tx = session.beginTransaction();&#10;            try {&#10;                session.persist(message);&#10;                session.flush();&#10;                tx.commit();&#10;                return message;&#10;            } catch (Exception e) {&#10;                tx.rollback();&#10;                throw e;&#10;            }&#10;        }&#10;    }&#10;&#10;    public List&lt;ProcessedMessage&gt; findAllByTenant(String tenantId) {&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenantId).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT p FROM ProcessedMessage p WHERE p.tenantId = :tenantId&quot;, ProcessedMessage.class)&#10;                    .setParameter(&quot;tenantId&quot;, tenantId)&#10;                    .getResultList();&#10;        }&#10;    }&#10;&#10;    public List&lt;ProcessedMessage&gt; findAll(String tenantId) {&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenantId).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT p FROM ProcessedMessage p&quot;, ProcessedMessage.class)&#10;                    .getResultList();&#10;        }&#10;    }&#10;&#10;    public long count(String tenantId) {&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenantId).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT COUNT(p) FROM ProcessedMessage p&quot;, Long.class)&#10;                    .getSingleResult();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.multitenant.repository;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import jakarta.enterprise.context.ApplicationScoped;&#10;import jakarta.inject.Inject;&#10;import org.hibernate.Session;&#10;import org.hibernate.SessionFactory;&#10;import org.hibernate.Transaction;&#10;import org.jboss.logging.Logger;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Repositório que resolve o tenant automaticamente a partir do TenantContext (ThreadLocal).&#10; * Graças ao Context Propagation, o TenantContext é propagado entre threads automaticamente,&#10; * dispensando a necessidade de passar tenantId como parâmetro.&#10; *&#10; * Abre sessões com sessionFactory.withOptions().tenantIdentifier() usando o tenant&#10; * do contexto propagado.&#10; */&#10;@ApplicationScoped&#10;public class ProcessedMessageRepository {&#10;&#10;    private static final Logger LOG = Logger.getLogger(ProcessedMessageRepository.class);&#10;&#10;    @Inject&#10;    SessionFactory sessionFactory;&#10;&#10;    /**&#10;     * Persiste uma mensagem no banco do tenant corrente (resolvido via TenantContext).&#10;     */&#10;    public ProcessedMessage save(ProcessedMessage message) {&#10;        String tenant = resolveCurrentTenant();&#10;        LOG.infov(&quot;Saving message [{0}] for tenant [{1}] on thread [{2}]&quot;,&#10;                message.getMessageId(), tenant, Thread.currentThread().getName());&#10;&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenant).openSession()) {&#10;            Transaction tx = session.beginTransaction();&#10;            try {&#10;                session.persist(message);&#10;                session.flush();&#10;                tx.commit();&#10;                return message;&#10;            } catch (Exception e) {&#10;                tx.rollback();&#10;                throw e;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca todas as mensagens do tenant corrente filtradas por tenantId.&#10;     */&#10;    public List&lt;ProcessedMessage&gt; findAllByTenant() {&#10;        String tenant = resolveCurrentTenant();&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenant).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT p FROM ProcessedMessage p WHERE p.tenantId = :tenantId&quot;, ProcessedMessage.class)&#10;                    .setParameter(&quot;tenantId&quot;, tenant)&#10;                    .getResultList();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca todas as mensagens do tenant corrente.&#10;     */&#10;    public List&lt;ProcessedMessage&gt; findAll() {&#10;        String tenant = resolveCurrentTenant();&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenant).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT p FROM ProcessedMessage p&quot;, ProcessedMessage.class)&#10;                    .getResultList();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Conta as mensagens do tenant corrente.&#10;     */&#10;    public long count() {&#10;        String tenant = resolveCurrentTenant();&#10;        try (Session session = sessionFactory.withOptions().tenantIdentifier(tenant).openSession()) {&#10;            return session&#10;                    .createQuery(&quot;SELECT COUNT(p) FROM ProcessedMessage p&quot;, Long.class)&#10;                    .getSingleResult();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resolve o tenant do TenantContext propagado. Lança exceção se não houver tenant definido.&#10;     */&#10;    private String resolveCurrentTenant() {&#10;        String tenant = TenantContext.getCurrentTenant();&#10;        if (tenant == null || tenant.isBlank()) {&#10;            throw new IllegalStateException(&#10;                    &quot;TenantContext não está definido na thread [&quot; + Thread.currentThread().getName()&#10;                            + &quot;]. Verifique se o tenant foi setado antes de chamar o repositório.&quot;);&#10;        }&#10;        return tenant;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/multitenant/resource/MessageResource.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/multitenant/resource/MessageResource.java" />
              <option name="originalContent" value="package com.example.multitenant.resource;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsConsumer;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import io.smallrye.mutiny.Multi;&#10;import io.smallrye.mutiny.infrastructure.Infrastructure;&#10;import io.smallrye.mutiny.Uni;&#10;import jakarta.ws.rs.*;&#10;import jakarta.ws.rs.core.MediaType;&#10;import jakarta.ws.rs.core.Response;&#10;import org.jboss.logging.Logger;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Resource REATIVO para interação com a mini-app.&#10; * Permite enviar mensagens para a fila de entrada, consultar mensagens processadas&#10; * e disparar manualmente o processamento.&#10; */&#10;@Path(&quot;/api/messages&quot;)&#10;@Produces(MediaType.APPLICATION_JSON)&#10;@Consumes(MediaType.APPLICATION_JSON)&#10;public class MessageResource {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MessageResource.class);&#10;&#10;    private final SqsClientService sqsClientService;&#10;    private final SqsConsumer sqsConsumer;&#10;    private final ProcessedMessageRepository repository;&#10;&#10;    public MessageResource(SqsClientService sqsClientService,&#10;                           SqsConsumer sqsConsumer,&#10;                           ProcessedMessageRepository repository) {&#10;        this.sqsClientService = sqsClientService;&#10;        this.sqsConsumer = sqsConsumer;&#10;        this.repository = repository;&#10;    }&#10;&#10;    /**&#10;     * Envia uma mensagem para a fila de entrada SQS.&#10;     */&#10;    @POST&#10;    @Path(&quot;/send&quot;)&#10;    public Uni&lt;Response&gt; sendMessage(SqsMessageDTO dto) {&#10;        LOG.infov(&quot;Sending message to input queue: {0}&quot;, dto);&#10;        return sqsClientService.sendToInputQueue(dto)&#10;                .map(resp -&gt; Response.accepted()&#10;                        .entity(new SendResponse(resp.messageId(), dto.getTenantId()))&#10;                        .build());&#10;    }&#10;&#10;    /**&#10;     * Envia múltiplas mensagens para a fila de entrada SQS.&#10;     */&#10;    @POST&#10;    @Path(&quot;/send-batch&quot;)&#10;    public Uni&lt;List&lt;SendResponse&gt;&gt; sendBatch(List&lt;SqsMessageDTO&gt; dtos) {&#10;        LOG.infov(&quot;Sending batch of {0} messages to input queue&quot;, dtos.size());&#10;        return Multi.createFrom().iterable(dtos)&#10;                .onItem().transformToUniAndMerge(dto -&gt;&#10;                        sqsClientService.sendToInputQueue(dto)&#10;                                .map(resp -&gt;&#10;                                        new SendResponse(resp.messageId(), dto.getTenantId()))&#10;                )&#10;                .collect().asList();&#10;    }&#10;&#10;    /**&#10;     * Dispara manualmente o processamento de mensagens da fila.&#10;     */&#10;    @POST&#10;    @Path(&quot;/process&quot;)&#10;    public Uni&lt;Response&gt; triggerProcessing() {&#10;        LOG.info(&quot;Manually triggering message processing&quot;);&#10;        return sqsConsumer.pollAndProcess()&#10;                .map(v -&gt; Response.ok().entity(&quot;{\&quot;status\&quot;:\&quot;processing triggered\&quot;}&quot;).build());&#10;    }&#10;&#10;    /**&#10;     * Consulta mensagens processadas de um tenant específico.&#10;     */&#10;    @GET&#10;    @Path(&quot;/processed/{tenantId}&quot;)&#10;    public Uni&lt;List&lt;ProcessedMessage&gt;&gt; getProcessedMessages(@PathParam(&quot;tenantId&quot;) String tenantId) {&#10;        return Uni.createFrom().item(() -&gt; {&#10;            TenantContext.setCurrentTenant(tenantId);&#10;            try {&#10;                return repository.findAllByTenant(tenantId);&#10;            } finally {&#10;                TenantContext.clear();&#10;            }&#10;        }).runSubscriptionOn(command -&gt; Thread.ofVirtual().start(command));&#10;    }&#10;&#10;    /**&#10;     * Health check simples.&#10;     */&#10;    @GET&#10;    @Path(&quot;/health&quot;)&#10;    public Uni&lt;Response&gt; health() {&#10;        return Uni.createFrom().item(Response.ok(&quot;{\&quot;status\&quot;:\&quot;UP\&quot;}&quot;).build());&#10;    }&#10;&#10;    public record SendResponse(String sqsMessageId, String tenantId) {}&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.multitenant.resource;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsConsumer;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import io.smallrye.mutiny.Multi;&#10;import io.smallrye.mutiny.infrastructure.Infrastructure;&#10;import io.smallrye.mutiny.Uni;&#10;import jakarta.ws.rs.*;&#10;import jakarta.ws.rs.core.MediaType;&#10;import jakarta.ws.rs.core.Response;&#10;import org.jboss.logging.Logger;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Resource REATIVO para interação com a mini-app.&#10; * Permite enviar mensagens para a fila de entrada, consultar mensagens processadas&#10; * e disparar manualmente o processamento.&#10; *&#10; * O TenantContext é propagado automaticamente via Context Propagation,&#10; * sem necessidade de passá-lo manualmente para os métodos do repositório.&#10; */&#10;@Path(&quot;/api/messages&quot;)&#10;@Produces(MediaType.APPLICATION_JSON)&#10;@Consumes(MediaType.APPLICATION_JSON)&#10;public class MessageResource {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MessageResource.class);&#10;&#10;    private final SqsClientService sqsClientService;&#10;    private final SqsConsumer sqsConsumer;&#10;    private final ProcessedMessageRepository repository;&#10;&#10;    public MessageResource(SqsClientService sqsClientService,&#10;                           SqsConsumer sqsConsumer,&#10;                           ProcessedMessageRepository repository) {&#10;        this.sqsClientService = sqsClientService;&#10;        this.sqsConsumer = sqsConsumer;&#10;        this.repository = repository;&#10;    }&#10;&#10;    /**&#10;     * Envia uma mensagem para a fila de entrada SQS.&#10;     */&#10;    @POST&#10;    @Path(&quot;/send&quot;)&#10;    public Uni&lt;Response&gt; sendMessage(SqsMessageDTO dto) {&#10;        LOG.infov(&quot;Sending message to input queue: {0}&quot;, dto);&#10;        return sqsClientService.sendToInputQueue(dto)&#10;                .map(resp -&gt; Response.accepted()&#10;                        .entity(new SendResponse(resp.messageId(), dto.getTenantId()))&#10;                        .build());&#10;    }&#10;&#10;    /**&#10;     * Envia múltiplas mensagens para a fila de entrada SQS.&#10;     */&#10;    @POST&#10;    @Path(&quot;/send-batch&quot;)&#10;    public Uni&lt;List&lt;SendResponse&gt;&gt; sendBatch(List&lt;SqsMessageDTO&gt; dtos) {&#10;        LOG.infov(&quot;Sending batch of {0} messages to input queue&quot;, dtos.size());&#10;        return Multi.createFrom().iterable(dtos)&#10;                .onItem().transformToUniAndMerge(dto -&gt;&#10;                        sqsClientService.sendToInputQueue(dto)&#10;                                .map(resp -&gt;&#10;                                        new SendResponse(resp.messageId(), dto.getTenantId()))&#10;                )&#10;                .collect().asList();&#10;    }&#10;&#10;    /**&#10;     * Dispara manualmente o processamento de mensagens da fila.&#10;     */&#10;    @POST&#10;    @Path(&quot;/process&quot;)&#10;    public Uni&lt;Response&gt; triggerProcessing() {&#10;        LOG.info(&quot;Manually triggering message processing&quot;);&#10;        return sqsConsumer.pollAndProcess()&#10;                .map(v -&gt; Response.ok().entity(&quot;{\&quot;status\&quot;:\&quot;processing triggered\&quot;}&quot;).build());&#10;    }&#10;&#10;    /**&#10;     * Consulta mensagens processadas de um tenant específico.&#10;     * Seta o TenantContext e o Context Propagation garante que ele será&#10;     * propagado para a thread de execução do repositório.&#10;     */&#10;    @GET&#10;    @Path(&quot;/processed/{tenantId}&quot;)&#10;    public Uni&lt;List&lt;ProcessedMessage&gt;&gt; getProcessedMessages(@PathParam(&quot;tenantId&quot;) String tenantId) {&#10;        // Seta o tenant no contexto — o Context Propagation propaga automaticamente&#10;        TenantContext.setCurrentTenant(tenantId);&#10;&#10;        return Uni.createFrom().item(() -&gt; repository.findAllByTenant())&#10;                .runSubscriptionOn(Infrastructure.getDefaultExecutor());&#10;    }&#10;&#10;    /**&#10;     * Health check simples.&#10;     */&#10;    @GET&#10;    @Path(&quot;/health&quot;)&#10;    public Uni&lt;Response&gt; health() {&#10;        return Uni.createFrom().item(Response.ok(&quot;{\&quot;status\&quot;:\&quot;UP\&quot;}&quot;).build());&#10;    }&#10;&#10;    public record SendResponse(String sqsMessageId, String tenantId) {}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/multitenant/service/MessageProcessingService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/multitenant/service/MessageProcessingService.java" />
              <option name="originalContent" value="package com.example.multitenant.service;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import io.smallrye.mutiny.Uni;&#10;import io.smallrye.mutiny.infrastructure.Infrastructure;&#10;import jakarta.enterprise.context.ApplicationScoped;&#10;import org.jboss.logging.Logger;&#10;&#10;/**&#10; * Serviço REATIVO que orquestra o processamento da mensagem:&#10; * 1. Seta o tenant no ThreadLocal&#10; * 2. Persiste no banco via repository bloqueante (runOnWorkerThread)&#10; * 3. Publica a mensagem processada na fila SQS de saída&#10; * 4. Limpa o TenantContext&#10; *&#10; * Ajuste: remover criação manual de virtual threads para garantir que o&#10; * contexto transacional e o TenantContext estejam presentes na mesma thread&#10; * em que o repositório é executado.&#10; */&#10;@ApplicationScoped&#10;public class MessageProcessingService {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MessageProcessingService.class);&#10;&#10;    private final ProcessedMessageRepository repository;&#10;    private final SqsClientService sqsClientService;&#10;&#10;    public MessageProcessingService(ProcessedMessageRepository repository, SqsClientService sqsClientService) {&#10;        this.repository = repository;&#10;        this.sqsClientService = sqsClientService;&#10;    }&#10;&#10;    /**&#10;     * Processa uma mensagem SQS de forma reativa.&#10;     * O bloco bloqueante (Hibernate ORM) roda na própria thread de subscription,&#10;     * garantindo que @Transactional e TenantContext sejam visíveis nessa thread.&#10;     */&#10;    public Uni&lt;ProcessedMessage&gt; processMessage(SqsMessageDTO dto) {&#10;        return Uni.createFrom().item(() -&gt; {&#10;                    LOG.infov(&quot;Processing message [{0}] for tenant [{1}] on thread [{2}]&quot;,&#10;                            dto.getMessageId(), dto.getTenantId(), Thread.currentThread().getName());&#10;&#10;                    ProcessedMessage entity = new ProcessedMessage(&#10;                            dto.getMessageId(),&#10;                            dto.getBody(),&#10;                            dto.getTenantId()&#10;                    );&#10;&#10;                    // repository.save() agora usa SessionFactory.withOptions().tenantIdentifier()&#10;                    // diretamente, sem depender de ThreadLocal&#10;                    return repository.save(entity);&#10;                })&#10;                // Executa o supplier em um executor gerenciado pelo Mutiny&#10;                .runSubscriptionOn(Infrastructure.getDefaultExecutor())&#10;                .flatMap(savedEntity -&gt; {&#10;                    // Após persistir, publica na fila de saída (reativo)&#10;                    SqsMessageDTO outputDto = new SqsMessageDTO(&#10;                            savedEntity.getMessageId(),&#10;                            savedEntity.getTenantId(),&#10;                            savedEntity.getBody()&#10;                    );&#10;                    return sqsClientService.publishProcessedMessage(outputDto)&#10;                            .replaceWith(savedEntity);&#10;                })&#10;                .invoke(saved -&gt; LOG.infov(&quot;Fully processed message [{0}] for tenant [{1}]&quot;,&#10;                        saved.getMessageId(), saved.getTenantId()));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.multitenant.service;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import io.smallrye.mutiny.Uni;&#10;import io.smallrye.mutiny.infrastructure.Infrastructure;&#10;import jakarta.enterprise.context.ApplicationScoped;&#10;import org.jboss.logging.Logger;&#10;&#10;/**&#10; * Serviço REATIVO que orquestra o processamento da mensagem:&#10; * 1. Seta o tenant no TenantContext (propagado automaticamente via Context Propagation)&#10; * 2. Persiste no banco via repository (que resolve o tenant do TenantContext)&#10; * 3. Publica a mensagem processada na fila SQS de saída&#10; *&#10; * Graças ao Context Propagation, o TenantContext é propagado automaticamente&#10; * entre threads, sem necessidade de passar o tenant manualmente para cada método.&#10; */&#10;@ApplicationScoped&#10;public class MessageProcessingService {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MessageProcessingService.class);&#10;&#10;    private final ProcessedMessageRepository repository;&#10;    private final SqsClientService sqsClientService;&#10;&#10;    public MessageProcessingService(ProcessedMessageRepository repository, SqsClientService sqsClientService) {&#10;        this.repository = repository;&#10;        this.sqsClientService = sqsClientService;&#10;    }&#10;&#10;    /**&#10;     * Processa uma mensagem SQS de forma reativa.&#10;     * Seta o TenantContext no início — o Context Propagation garante que ele&#10;     * será propagado para todas as threads subsequentes do pipeline.&#10;     */&#10;    public Uni&lt;ProcessedMessage&gt; processMessage(SqsMessageDTO dto) {&#10;        // Seta o tenant ANTES de criar o pipeline reativo.&#10;        // O Context Propagation captura esse valor e o propaga para as threads do executor.&#10;        TenantContext.setCurrentTenant(dto.getTenantId());&#10;&#10;        return Uni.createFrom().item(() -&gt; {&#10;                    LOG.infov(&quot;Processing message [{0}] for tenant [{1}] on thread [{2}]&quot;,&#10;                            dto.getMessageId(), dto.getTenantId(), Thread.currentThread().getName());&#10;&#10;                    ProcessedMessage entity = new ProcessedMessage(&#10;                            dto.getMessageId(),&#10;                            dto.getBody(),&#10;                            dto.getTenantId()&#10;                    );&#10;&#10;                    // O repository resolve o tenant automaticamente do TenantContext propagado&#10;                    return repository.save(entity);&#10;                })&#10;                .runSubscriptionOn(Infrastructure.getDefaultExecutor())&#10;                .flatMap(savedEntity -&gt; {&#10;                    SqsMessageDTO outputDto = new SqsMessageDTO(&#10;                            savedEntity.getMessageId(),&#10;                            savedEntity.getTenantId(),&#10;                            savedEntity.getBody()&#10;                    );&#10;                    return sqsClientService.publishProcessedMessage(outputDto)&#10;                            .replaceWith(savedEntity);&#10;                })&#10;                .invoke(saved -&gt; LOG.infov(&quot;Fully processed message [{0}] for tenant [{1}]&quot;,&#10;                        saved.getMessageId(), saved.getTenantId()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/multitenant/tenant/TenantContextProvider.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/multitenant/tenant/TenantContextProvider.java" />
              <option name="originalContent" value="package com.example.multitenant.tenant;&#10;&#10;import org.eclipse.microprofile.context.spi.ThreadContextProvider;&#10;import org.eclipse.microprofile.context.spi.ThreadContextSnapshot;&#10;import org.eclipse.microprofile.context.spi.ThreadContextController;&#10;&#10;import java.util.Map;&#10;&#10;/**&#10; * Provider de Context Propagation para o TenantContext.&#10; * Registra-se via SPI (META-INF/services) para que o SmallRye Context Propagation&#10; * capture e restaure automaticamente o tenant ao trocar de thread.&#10; *&#10; * Isso garante thread-safety sem precisar passar o tenantId manualmente&#10; * para todos os métodos.&#10; */&#10;public class TenantContextProvider implements ThreadContextProvider {&#10;&#10;    /**&#10;     * Tipo único que identifica este contexto no MicroProfile Context Propagation.&#10;     */&#10;    public static final String TENANT_CONTEXT_TYPE = &quot;tenant-context&quot;;&#10;&#10;    @Override&#10;    public ThreadContextSnapshot currentContext(Map&lt;String, String&gt; props) {&#10;        // Captura o tenant da thread atual no momento da criação do snapshot&#10;        String currentTenant = TenantContext.getCurrentTenant();&#10;&#10;        return () -&gt; {&#10;            // Quando a tarefa vai rodar em outra thread, salva o tenant anterior&#10;            String previousTenant = TenantContext.getCurrentTenant();&#10;&#10;            // Restaura o tenant capturado&#10;            if (currentTenant != null) {&#10;                TenantContext.setCurrentTenant(currentTenant);&#10;            } else {&#10;                TenantContext.clear();&#10;            }&#10;&#10;            // Retorna um controller que restaura o estado anterior quando a tarefa termina&#10;            return () -&gt; {&#10;                if (previousTenant != null) {&#10;                    TenantContext.setCurrentTenant(previousTenant);&#10;                } else {&#10;                    TenantContext.clear();&#10;                }&#10;            };&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public ThreadContextSnapshot clearedContext(Map&lt;String, String&gt; props) {&#10;        return () -&gt; {&#10;            String previousTenant = TenantContext.getCurrentTenant();&#10;            TenantContext.clear();&#10;&#10;            return () -&gt; {&#10;                if (previousTenant != null) {&#10;                    TenantContext.setCurrentTenant(previousTenant);&#10;                } else {&#10;                    TenantContext.clear();&#10;                }&#10;            };&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public String getThreadContextType() {&#10;        return TENANT_CONTEXT_TYPE;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.multitenant.tenant;&#10;&#10;import org.eclipse.microprofile.context.spi.ThreadContextProvider;&#10;import org.eclipse.microprofile.context.spi.ThreadContextSnapshot;&#10;&#10;import java.util.Map;&#10;&#10;/**&#10; * Provider de Context Propagation para o TenantContext.&#10; * Registra-se via SPI (META-INF/services) para que o SmallRye Context Propagation&#10; * capture e restaure automaticamente o tenant ao trocar de thread.&#10; *&#10; * Isso garante thread-safety sem precisar passar o tenantId manualmente&#10; * para todos os métodos.&#10; */&#10;public class TenantContextProvider implements ThreadContextProvider {&#10;&#10;    /**&#10;     * Tipo único que identifica este contexto no MicroProfile Context Propagation.&#10;     */&#10;    public static final String TENANT_CONTEXT_TYPE = &quot;tenant-context&quot;;&#10;&#10;    @Override&#10;    public ThreadContextSnapshot currentContext(Map&lt;String, String&gt; props) {&#10;        // Captura o tenant da thread atual no momento da criação do snapshot&#10;        String currentTenant = TenantContext.getCurrentTenant();&#10;&#10;        return () -&gt; {&#10;            // Quando a tarefa vai rodar em outra thread, salva o tenant anterior&#10;            String previousTenant = TenantContext.getCurrentTenant();&#10;&#10;            // Restaura o tenant capturado&#10;            if (currentTenant != null) {&#10;                TenantContext.setCurrentTenant(currentTenant);&#10;            } else {&#10;                TenantContext.clear();&#10;            }&#10;&#10;            // Retorna um controller que restaura o estado anterior quando a tarefa termina&#10;            return () -&gt; {&#10;                if (previousTenant != null) {&#10;                    TenantContext.setCurrentTenant(previousTenant);&#10;                } else {&#10;                    TenantContext.clear();&#10;                }&#10;            };&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public ThreadContextSnapshot clearedContext(Map&lt;String, String&gt; props) {&#10;        return () -&gt; {&#10;            String previousTenant = TenantContext.getCurrentTenant();&#10;            TenantContext.clear();&#10;&#10;            return () -&gt; {&#10;                if (previousTenant != null) {&#10;                    TenantContext.setCurrentTenant(previousTenant);&#10;                } else {&#10;                    TenantContext.clear();&#10;                }&#10;            };&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public String getThreadContextType() {&#10;        return TENANT_CONTEXT_TYPE;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/example/multitenant/MultiTenantThreadSafetyTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/example/multitenant/MultiTenantThreadSafetyTest.java" />
              <option name="originalContent" value="package com.example.multitenant;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsConsumer;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import io.quarkus.test.common.QuarkusTestResource;&#10;import io.quarkus.test.junit.QuarkusTest;&#10;import jakarta.inject.Inject;&#10;import org.eclipse.microprofile.config.inject.ConfigProperty;&#10;import org.jboss.logging.Logger;&#10;import org.junit.jupiter.api.*;&#10;import software.amazon.awssdk.services.sqs.model.Message;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.ResultSet;&#10;import java.sql.Statement;&#10;import java.time.Duration;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.stream.Collectors;&#10;&#10;import static org.awaitility.Awaitility.await;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Teste de integração multi-thread que valida:&#10; *&#10; * 1. Thread-safety: múltiplas threads processando mensagens de tenants diferentes&#10; *    simultaneamente NÃO misturam dados entre bancos.&#10; * 2. Cada mensagem é persistida no banco CORRETO (do seu tenant).&#10; * 3. Cada mensagem processada é publicada na fila de saída com o tenant correto.&#10; * 4. Nenhum tenant é &quot;perdido&quot; entre threads.&#10; *&#10; * Usa Testcontainers com:&#10; * - PostgreSQL (3 bancos: tenant_a, tenant_b, tenant_c)&#10; * - LocalStack (SQS: input-queue, output-queue)&#10; */&#10;@QuarkusTest&#10;@QuarkusTestResource(TestContainersResource.class)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;class MultiTenantThreadSafetyTest {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MultiTenantThreadSafetyTest.class);&#10;&#10;    private static final List&lt;String&gt; TENANTS = List.of(&quot;tenant_a&quot;, &quot;tenant_b&quot;, &quot;tenant_c&quot;);&#10;    private static final int MESSAGES_PER_TENANT = 30;&#10;    private static final int TOTAL_MESSAGES = TENANTS.size() * MESSAGES_PER_TENANT; // 90&#10;&#10;    @Inject&#10;    SqsClientService sqsClientService;&#10;&#10;    @Inject&#10;    SqsConsumer sqsConsumer;&#10;&#10;    @Inject&#10;    ProcessedMessageRepository repository;&#10;&#10;    @Inject&#10;    ObjectMapper objectMapper;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.host&quot;)&#10;    String tenantDbHost;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.port&quot;)&#10;    int tenantDbPort;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.username&quot;)&#10;    String tenantDbUser;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.password&quot;)&#10;    String tenantDbPass;&#10;&#10;    @BeforeEach&#10;    void setup() {&#10;        // Desabilita o scheduler automático para controle manual&#10;        sqsConsumer.setEnabled(false);&#10;    }&#10;&#10;    /**&#10;     * TESTE PRINCIPAL: envia 90 mensagens (30 por tenant) para a fila de entrada,&#10;     * processa todas em paralelo com transformToUniAndMerge (max concurrency 20),&#10;     * e valida que cada tenant recebeu suas 30 mensagens no banco correto e na fila de saída.&#10;     */&#10;    @Test&#10;    @Order(1)&#10;    void shouldProcessMessagesForCorrectTenantAcrossMultipleThreads() throws Exception {&#10;        LOG.info(&quot;=== STARTING MULTI-TENANT THREAD-SAFETY TEST ===&quot;);&#10;        LOG.infov(&quot;Tenants: {0}, Messages per tenant: {1}, Total: {2}&quot;,&#10;                TENANTS, MESSAGES_PER_TENANT, TOTAL_MESSAGES);&#10;&#10;        // ── STEP 1: Envia todas as mensagens para a fila de entrada ──&#10;        LOG.info(&quot;STEP 1: Sending messages to input queue...&quot;);&#10;        List&lt;SqsMessageDTO&gt; allMessages = new ArrayList&lt;&gt;();&#10;&#10;        for (String tenant : TENANTS) {&#10;            for (int i = 0; i &lt; MESSAGES_PER_TENANT; i++) {&#10;                SqsMessageDTO dto = new SqsMessageDTO(&#10;                        &quot;msg-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Body for &quot; + tenant + &quot; message &quot; + i&#10;                );&#10;                allMessages.add(dto);&#10;            }&#10;        }&#10;&#10;        // Envia todas em paralelo&#10;        int sent = 0;&#10;        for (SqsMessageDTO dto : allMessages) {&#10;            try {&#10;                sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;                sent++;&#10;            } catch (Exception e) {&#10;                LOG.errorv(&quot;Failed to send message {0}: {1}&quot;, dto.getMessageId(), e.getMessage());&#10;            }&#10;        }&#10;&#10;        LOG.infov(&quot;Sent {0} messages to input queue&quot;, sent);&#10;        assertEquals(TOTAL_MESSAGES, sent, &quot;All messages should be sent&quot;);&#10;&#10;        // ── STEP 2: Processa todas as mensagens via polling ──&#10;        LOG.info(&quot;STEP 2: Processing messages from input queue...&quot;);&#10;        AtomicInteger totalProcessed = new AtomicInteger(0);&#10;        Set&lt;String&gt; threadsUsed = ConcurrentHashMap.newKeySet();&#10;&#10;        // Polling loop até processar tudo (máximo 120s)&#10;        await().atMost(Duration.ofSeconds(120))&#10;                .pollInterval(Duration.ofSeconds(2))&#10;                .untilAsserted(() -&gt; {&#10;                    // Recebe batch da fila&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(10));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        LOG.infov(&quot;Received batch of {0} messages, processing...&quot;, messages.size());&#10;&#10;                        // Processa com transformToUniAndMerge&#10;                        sqsConsumer.processMessages(messages)&#10;                                .onItem().invoke(() -&gt; {&#10;                                    totalProcessed.incrementAndGet();&#10;                                    threadsUsed.add(Thread.currentThread().getName());&#10;                                })&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(30));&#10;                    }&#10;&#10;                    // Verifica contagem em cada banco&#10;                    int totalInDbs = 0;&#10;                    for (String tenant : TENANTS) {&#10;                        int count = countMessagesInTenantDb(tenant);&#10;                        totalInDbs += count;&#10;                    }&#10;                    LOG.infov(&quot;Total messages in all DBs: {0}/{1}&quot;, totalInDbs, TOTAL_MESSAGES);&#10;                    assertEquals(TOTAL_MESSAGES, totalInDbs,&#10;                            &quot;All messages should be persisted across all tenant databases&quot;);&#10;                });&#10;&#10;        LOG.infov(&quot;Threads used during processing: {0}&quot;, threadsUsed);&#10;&#10;        // ── STEP 3: Valida que cada tenant tem EXATAMENTE suas mensagens no banco correto ──&#10;        LOG.info(&quot;STEP 3: Validating per-tenant database integrity...&quot;);&#10;&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; tenantMessages = findMessagesInTenantDb(tenant);&#10;&#10;            // Cada tenant deve ter exatamente MESSAGES_PER_TENANT mensagens&#10;            assertEquals(MESSAGES_PER_TENANT, tenantMessages.size(),&#10;                    &quot;Tenant [&quot; + tenant + &quot;] should have exactly &quot; + MESSAGES_PER_TENANT + &quot; messages&quot;);&#10;&#10;            // Todas as mensagens devem pertencer ao tenant correto&#10;            for (ProcessedMessage pm : tenantMessages) {&#10;                assertEquals(tenant, pm.getTenantId(),&#10;                        &quot;Message [&quot; + pm.getMessageId() + &quot;] should belong to tenant [&quot; + tenant&#10;                                + &quot;] but found tenantId=[&quot; + pm.getTenantId() + &quot;]&quot;);&#10;&#10;                assertTrue(pm.getMessageId().startsWith(&quot;msg-&quot; + tenant),&#10;                        &quot;Message ID [&quot; + pm.getMessageId() + &quot;] should start with 'msg-&quot; + tenant + &quot;'&quot;);&#10;&#10;                assertNotNull(pm.getProcessedAt(), &quot;processedAt should not be null&quot;);&#10;                assertNotNull(pm.getThreadName(), &quot;threadName should not be null&quot;);&#10;            }&#10;&#10;            // Verifica que não há mensagens de OUTRO tenant neste banco&#10;            Set&lt;String&gt; uniqueTenants = tenantMessages.stream()&#10;                    .map(ProcessedMessage::getTenantId)&#10;                    .collect(Collectors.toSet());&#10;            assertEquals(1, uniqueTenants.size(),&#10;                    &quot;Only one tenant should exist in database [&quot; + tenant + &quot;]: &quot; + uniqueTenants);&#10;            assertTrue(uniqueTenants.contains(tenant),&#10;                    &quot;Database [&quot; + tenant + &quot;] should only contain messages for [&quot; + tenant + &quot;]&quot;);&#10;&#10;            LOG.infov(&quot;✓ Tenant [{0}]: {1} messages validated OK&quot;, tenant, tenantMessages.size());&#10;        }&#10;&#10;        // ── STEP 4: Valida mensagens publicadas na fila de saída ──&#10;        LOG.info(&quot;STEP 4: Validating output queue messages...&quot;);&#10;        Map&lt;String, List&lt;SqsMessageDTO&gt;&gt; outputByTenant = new HashMap&lt;&gt;();&#10;&#10;        // Drena todas as mensagens da fila de saída&#10;        await().atMost(Duration.ofSeconds(30))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .until(() -&gt; {&#10;                    List&lt;Message&gt; outputMsgs = sqsClientService.receiveFromOutputQueue()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    for (Message msg : outputMsgs) {&#10;                        SqsMessageDTO dto = objectMapper.readValue(msg.body(), SqsMessageDTO.class);&#10;                        outputByTenant.computeIfAbsent(dto.getTenantId(), k -&gt; new ArrayList&lt;&gt;()).add(dto);&#10;                    }&#10;&#10;                    int totalOutput = outputByTenant.values().stream().mapToInt(List::size).sum();&#10;                    LOG.infov(&quot;Output queue drained so far: {0}/{1}&quot;, totalOutput, TOTAL_MESSAGES);&#10;                    return totalOutput &gt;= TOTAL_MESSAGES;&#10;                });&#10;&#10;        // Valida que cada tenant tem suas mensagens na fila de saída&#10;        for (String tenant : TENANTS) {&#10;            List&lt;SqsMessageDTO&gt; outputMsgs = outputByTenant.getOrDefault(tenant, List.of());&#10;            assertEquals(MESSAGES_PER_TENANT, outputMsgs.size(),&#10;                    &quot;Output queue should have &quot; + MESSAGES_PER_TENANT + &quot; messages for tenant [&quot; + tenant + &quot;]&quot;);&#10;&#10;            for (SqsMessageDTO dto : outputMsgs) {&#10;                assertEquals(tenant, dto.getTenantId(),&#10;                        &quot;Output message should have correct tenantId&quot;);&#10;                assertTrue(dto.getMessageId().startsWith(&quot;msg-&quot; + tenant),&#10;                        &quot;Output messageId should match tenant&quot;);&#10;            }&#10;&#10;            LOG.infov(&quot;✓ Output queue tenant [{0}]: {1} messages validated OK&quot;, tenant, outputMsgs.size());&#10;        }&#10;&#10;        // ── STEP 5: Verifica que nenhum tenant estranho apareceu ──&#10;        LOG.info(&quot;STEP 5: Verifying no cross-tenant contamination...&quot;);&#10;        Set&lt;String&gt; allTenantsInOutput = outputByTenant.keySet();&#10;        assertEquals(new HashSet&lt;&gt;(TENANTS), allTenantsInOutput,&#10;                &quot;Only expected tenants should appear in output&quot;);&#10;&#10;        LOG.info(&quot;=== MULTI-TENANT THREAD-SAFETY TEST PASSED ===&quot;);&#10;        LOG.infov(&quot;Total messages processed: {0}&quot;, TOTAL_MESSAGES);&#10;        LOG.infov(&quot;Threads used: {0}&quot;, threadsUsed.size());&#10;    }&#10;&#10;    /**&#10;     * TESTE DE STRESS: envia mensagens intercaladas de tenants diferentes&#10;     * para maximizar a chance de race conditions.&#10;     */&#10;    @Test&#10;    @Order(2)&#10;    void shouldHandleInterleavedTenantMessagesWithoutMixup() throws Exception {&#10;        LOG.info(&quot;=== STARTING INTERLEAVED TENANT TEST ===&quot;);&#10;&#10;        int messagesPerTenant = 10;&#10;        List&lt;SqsMessageDTO&gt; interleavedMessages = new ArrayList&lt;&gt;();&#10;&#10;        // Intercala mensagens: tenant_a, tenant_b, tenant_c, tenant_a, tenant_b, tenant_c, ...&#10;        for (int i = 0; i &lt; messagesPerTenant; i++) {&#10;            for (String tenant : TENANTS) {&#10;                interleavedMessages.add(new SqsMessageDTO(&#10;                        &quot;interleaved-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Interleaved body &quot; + tenant + &quot; &quot; + i&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Envia todas&#10;        for (SqsMessageDTO dto : interleavedMessages) {&#10;            sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;        }&#10;&#10;        int expectedTotal = messagesPerTenant * TENANTS.size();&#10;&#10;        // Processa&#10;        await().atMost(Duration.ofSeconds(60))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .untilAsserted(() -&gt; {&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        sqsConsumer.processMessages(messages)&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(15));&#10;                    }&#10;&#10;                    // Conta total em todos os bancos (inclui mensagens do teste anterior)&#10;                    for (String tenant : TENANTS) {&#10;                        List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;                        // Filtra só as deste teste&#10;                        long interleavedCount = msgs.stream()&#10;                                .filter(m -&gt; m.getMessageId().startsWith(&quot;interleaved-&quot; + tenant))&#10;                                .count();&#10;                        assertEquals(messagesPerTenant, (int) interleavedCount,&#10;                                &quot;Tenant [&quot; + tenant + &quot;] should have &quot; + messagesPerTenant + &quot; interleaved messages&quot;);&#10;                    }&#10;                });&#10;&#10;        // Valida integridade: nenhuma mensagem de tenant errado&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;            for (ProcessedMessage pm : msgs) {&#10;                assertEquals(tenant, pm.getTenantId(),&#10;                        &quot;Cross-tenant contamination detected! Message [&quot; + pm.getMessageId()&#10;                                + &quot;] has tenantId [&quot; + pm.getTenantId()&#10;                                + &quot;] but is in database [&quot; + tenant + &quot;]&quot;);&#10;            }&#10;        }&#10;&#10;        LOG.info(&quot;=== INTERLEAVED TENANT TEST PASSED ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * TESTE DE CONCORRÊNCIA MÁXIMA: dispara processamento de múltiplas threads Java&#10;     * simultaneamente para forçar race conditions no TenantContext.&#10;     */&#10;    @Test&#10;    @Order(3)&#10;    void shouldMaintainTenantIsolationUnderHighConcurrency() throws Exception {&#10;        LOG.info(&quot;=== STARTING HIGH CONCURRENCY TEST ===&quot;);&#10;&#10;        int messagesPerTenant = 20;&#10;        List&lt;SqsMessageDTO&gt; allMessages = new ArrayList&lt;&gt;();&#10;&#10;        for (String tenant : TENANTS) {&#10;            for (int i = 0; i &lt; messagesPerTenant; i++) {&#10;                allMessages.add(new SqsMessageDTO(&#10;                        &quot;concurrent-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Concurrent body &quot; + tenant + &quot; &quot; + i&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Shuffle para máxima mistura de tenants&#10;        Collections.shuffle(allMessages);&#10;&#10;        // Envia todas&#10;        for (SqsMessageDTO dto : allMessages) {&#10;            sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;        }&#10;&#10;        // Processa tudo de uma vez com alta concorrência&#10;        await().atMost(Duration.ofSeconds(90))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .untilAsserted(() -&gt; {&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        sqsConsumer.processMessages(messages)&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(20));&#10;                    }&#10;&#10;                    for (String tenant : TENANTS) {&#10;                        List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;                        long concurrentCount = msgs.stream()&#10;                                .filter(m -&gt; m.getMessageId().startsWith(&quot;concurrent-&quot; + tenant))&#10;                                .count();&#10;                        assertEquals(messagesPerTenant, (int) concurrentCount,&#10;                                &quot;Tenant [&quot; + tenant + &quot;] should have &quot; + messagesPerTenant + &quot; concurrent messages&quot;);&#10;                    }&#10;                });&#10;&#10;        // Valida ZERO cross-tenant contamination&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;            Set&lt;String&gt; tenantIds = msgs.stream()&#10;                    .map(ProcessedMessage::getTenantId)&#10;                    .collect(Collectors.toSet());&#10;&#10;            assertEquals(Set.of(tenant), tenantIds,&#10;                    &quot;Database [&quot; + tenant + &quot;] should ONLY contain tenant [&quot; + tenant&#10;                            + &quot;] but found: &quot; + tenantIds);&#10;&#10;            // Verifica que nenhum messageId de outro tenant acabou neste banco&#10;            for (ProcessedMessage pm : msgs) {&#10;                assertFalse(&#10;                        TENANTS.stream()&#10;                                .filter(t -&gt; !t.equals(tenant))&#10;                                .anyMatch(otherTenant -&gt; pm.getMessageId().contains(otherTenant)),&#10;                        &quot;Message [&quot; + pm.getMessageId() + &quot;] from another tenant found in database [&quot; + tenant + &quot;]&quot;);&#10;            }&#10;        }&#10;&#10;        LOG.info(&quot;=== HIGH CONCURRENCY TEST PASSED ===&quot;);&#10;    }&#10;&#10;    // ── Helper methods ──&#10;&#10;    private int countMessagesInTenantDb(String tenantId) {&#10;        String url = String.format(&quot;jdbc:postgresql://%s:%d/%s&quot;, tenantDbHost, tenantDbPort, tenantId);&#10;        try (Connection conn = DriverManager.getConnection(url, tenantDbUser, tenantDbPass);&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&quot;SELECT COUNT(*) FROM processed_message&quot;)) {&#10;            if (rs.next()) {&#10;                return rs.getInt(1);&#10;            }&#10;            return 0;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to count messages in tenant DB &quot; + tenantId, e);&#10;        }&#10;    }&#10;&#10;    private List&lt;ProcessedMessage&gt; findMessagesInTenantDb(String tenantId) {&#10;        String url = String.format(&quot;jdbc:postgresql://%s:%d/%s&quot;, tenantDbHost, tenantDbPort, tenantId);&#10;        List&lt;ProcessedMessage&gt; result = new ArrayList&lt;&gt;();&#10;        try (Connection conn = DriverManager.getConnection(url, tenantDbUser, tenantDbPass);&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&quot;SELECT message_id, body, tenant_id, processed_at, thread_name FROM processed_message&quot;)) {&#10;            while (rs.next()) {&#10;                ProcessedMessage pm = new ProcessedMessage(&#10;                        rs.getString(&quot;message_id&quot;),&#10;                        rs.getString(&quot;body&quot;),&#10;                        rs.getString(&quot;tenant_id&quot;)&#10;                );&#10;                pm.setProcessedAt(rs.getTimestamp(&quot;processed_at&quot;).toInstant());&#10;                pm.setThreadName(rs.getString(&quot;thread_name&quot;));&#10;                result.add(pm);&#10;            }&#10;            return result;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to read messages from tenant DB &quot; + tenantId, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.multitenant;&#10;&#10;import com.example.multitenant.entity.ProcessedMessage;&#10;import com.example.multitenant.messaging.SqsClientService;&#10;import com.example.multitenant.messaging.SqsConsumer;&#10;import com.example.multitenant.messaging.SqsMessageDTO;&#10;import com.example.multitenant.repository.ProcessedMessageRepository;&#10;import com.example.multitenant.tenant.TenantContext;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import io.quarkus.test.common.QuarkusTestResource;&#10;import io.quarkus.test.junit.QuarkusTest;&#10;import jakarta.inject.Inject;&#10;import org.eclipse.microprofile.config.inject.ConfigProperty;&#10;import org.jboss.logging.Logger;&#10;import org.junit.jupiter.api.*;&#10;import software.amazon.awssdk.services.sqs.model.Message;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.ResultSet;&#10;import java.sql.Statement;&#10;import java.time.Duration;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;import java.util.stream.Collectors;&#10;&#10;import static org.awaitility.Awaitility.await;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Teste de integração multi-thread que valida:&#10; *&#10; * 1. Thread-safety: múltiplas threads processando mensagens de tenants diferentes&#10; *    simultaneamente NÃO misturam dados entre bancos.&#10; * 2. Context Propagation: o TenantContext é propagado automaticamente entre threads&#10; *    pelo SmallRye Context Propagation, sem necessidade de passar tenant manualmente.&#10; * 3. Cada mensagem é persistida no banco CORRETO (do seu tenant).&#10; * 4. Cada mensagem processada é publicada na fila de saída com o tenant correto.&#10; * 5. Nenhum tenant é &quot;perdido&quot; entre threads.&#10; *&#10; * Usa Testcontainers com:&#10; * - PostgreSQL (3 bancos: tenant_a, tenant_b, tenant_c)&#10; * - LocalStack (SQS: input-queue, output-queue)&#10; */&#10;@QuarkusTest&#10;@QuarkusTestResource(TestContainersResource.class)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;class MultiTenantThreadSafetyTest {&#10;&#10;    private static final Logger LOG = Logger.getLogger(MultiTenantThreadSafetyTest.class);&#10;&#10;    private static final List&lt;String&gt; TENANTS = List.of(&quot;tenant_a&quot;, &quot;tenant_b&quot;, &quot;tenant_c&quot;);&#10;    private static final int MESSAGES_PER_TENANT = 30;&#10;    private static final int TOTAL_MESSAGES = TENANTS.size() * MESSAGES_PER_TENANT; // 90&#10;&#10;    @Inject&#10;    SqsClientService sqsClientService;&#10;&#10;    @Inject&#10;    SqsConsumer sqsConsumer;&#10;&#10;    @Inject&#10;    ProcessedMessageRepository repository;&#10;&#10;    @Inject&#10;    ObjectMapper objectMapper;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.host&quot;)&#10;    String tenantDbHost;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.port&quot;)&#10;    int tenantDbPort;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.username&quot;)&#10;    String tenantDbUser;&#10;&#10;    @ConfigProperty(name = &quot;app.tenant.db.password&quot;)&#10;    String tenantDbPass;&#10;&#10;    @BeforeEach&#10;    void setup() {&#10;        // Desabilita o scheduler automático para controle manual&#10;        sqsConsumer.setEnabled(false);&#10;    }&#10;&#10;    @AfterEach&#10;    void cleanup() {&#10;        // Garante que o TenantContext é limpo após cada teste&#10;        TenantContext.clear();&#10;    }&#10;&#10;    /**&#10;     * TESTE PRINCIPAL: envia 90 mensagens (30 por tenant) para a fila de entrada,&#10;     * processa todas em paralelo com transformToUniAndMerge (max concurrency 20),&#10;     * e valida que cada tenant recebeu suas 30 mensagens no banco correto e na fila de saída.&#10;     *&#10;     * Valida que o Context Propagation propaga o TenantContext corretamente entre threads.&#10;     */&#10;    @Test&#10;    @Order(1)&#10;    void shouldProcessMessagesForCorrectTenantWithContextPropagation() throws Exception {&#10;        LOG.info(&quot;=== STARTING MULTI-TENANT CONTEXT PROPAGATION TEST ===&quot;);&#10;        LOG.infov(&quot;Tenants: {0}, Messages per tenant: {1}, Total: {2}&quot;,&#10;                TENANTS, MESSAGES_PER_TENANT, TOTAL_MESSAGES);&#10;&#10;        // ── STEP 1: Envia todas as mensagens para a fila de entrada ──&#10;        LOG.info(&quot;STEP 1: Sending messages to input queue...&quot;);&#10;        List&lt;SqsMessageDTO&gt; allMessages = new ArrayList&lt;&gt;();&#10;&#10;        for (String tenant : TENANTS) {&#10;            for (int i = 0; i &lt; MESSAGES_PER_TENANT; i++) {&#10;                SqsMessageDTO dto = new SqsMessageDTO(&#10;                        &quot;msg-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Body for &quot; + tenant + &quot; message &quot; + i&#10;                );&#10;                allMessages.add(dto);&#10;            }&#10;        }&#10;&#10;        // Envia todas em paralelo&#10;        int sent = 0;&#10;        for (SqsMessageDTO dto : allMessages) {&#10;            try {&#10;                sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;                sent++;&#10;            } catch (Exception e) {&#10;                LOG.errorv(&quot;Failed to send message {0}: {1}&quot;, dto.getMessageId(), e.getMessage());&#10;            }&#10;        }&#10;&#10;        LOG.infov(&quot;Sent {0} messages to input queue&quot;, sent);&#10;        assertEquals(TOTAL_MESSAGES, sent, &quot;All messages should be sent&quot;);&#10;&#10;        // ── STEP 2: Processa todas as mensagens via polling ──&#10;        LOG.info(&quot;STEP 2: Processing messages from input queue (Context Propagation active)...&quot;);&#10;        AtomicInteger totalProcessed = new AtomicInteger(0);&#10;        Set&lt;String&gt; threadsUsed = ConcurrentHashMap.newKeySet();&#10;&#10;        // Polling loop até processar tudo (máximo 120s)&#10;        await().atMost(Duration.ofSeconds(120))&#10;                .pollInterval(Duration.ofSeconds(2))&#10;                .untilAsserted(() -&gt; {&#10;                    // Recebe batch da fila&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(10));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        LOG.infov(&quot;Received batch of {0} messages, processing...&quot;, messages.size());&#10;&#10;                        // Processa com transformToUniAndMerge — o TenantContext é propagado&#10;                        // automaticamente para cada thread de processamento&#10;                        sqsConsumer.processMessages(messages)&#10;                                .onItem().invoke(() -&gt; {&#10;                                    totalProcessed.incrementAndGet();&#10;                                    threadsUsed.add(Thread.currentThread().getName());&#10;                                })&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(30));&#10;                    }&#10;&#10;                    // Verifica contagem em cada banco&#10;                    int totalInDbs = 0;&#10;                    for (String tenant : TENANTS) {&#10;                        int count = countMessagesInTenantDb(tenant);&#10;                        totalInDbs += count;&#10;                    }&#10;                    LOG.infov(&quot;Total messages in all DBs: {0}/{1}&quot;, totalInDbs, TOTAL_MESSAGES);&#10;                    assertEquals(TOTAL_MESSAGES, totalInDbs,&#10;                            &quot;All messages should be persisted across all tenant databases&quot;);&#10;                });&#10;&#10;        LOG.infov(&quot;Threads used during processing: {0}&quot;, threadsUsed);&#10;&#10;        // ── STEP 3: Valida que cada tenant tem EXATAMENTE suas mensagens no banco correto ──&#10;        LOG.info(&quot;STEP 3: Validating per-tenant database integrity...&quot;);&#10;&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; tenantMessages = findMessagesInTenantDb(tenant);&#10;&#10;            // Cada tenant deve ter exatamente MESSAGES_PER_TENANT mensagens&#10;            assertEquals(MESSAGES_PER_TENANT, tenantMessages.size(),&#10;                    &quot;Tenant [&quot; + tenant + &quot;] should have exactly &quot; + MESSAGES_PER_TENANT + &quot; messages&quot;);&#10;&#10;            // Todas as mensagens devem pertencer ao tenant correto&#10;            for (ProcessedMessage pm : tenantMessages) {&#10;                assertEquals(tenant, pm.getTenantId(),&#10;                        &quot;Message [&quot; + pm.getMessageId() + &quot;] should belong to tenant [&quot; + tenant&#10;                                + &quot;] but found tenantId=[&quot; + pm.getTenantId() + &quot;]&quot;);&#10;&#10;                assertTrue(pm.getMessageId().startsWith(&quot;msg-&quot; + tenant),&#10;                        &quot;Message ID [&quot; + pm.getMessageId() + &quot;] should start with 'msg-&quot; + tenant + &quot;'&quot;);&#10;&#10;                assertNotNull(pm.getProcessedAt(), &quot;processedAt should not be null&quot;);&#10;                assertNotNull(pm.getThreadName(), &quot;threadName should not be null&quot;);&#10;            }&#10;&#10;            // Verifica que não há mensagens de OUTRO tenant neste banco&#10;            Set&lt;String&gt; uniqueTenants = tenantMessages.stream()&#10;                    .map(ProcessedMessage::getTenantId)&#10;                    .collect(Collectors.toSet());&#10;            assertEquals(1, uniqueTenants.size(),&#10;                    &quot;Only one tenant should exist in database [&quot; + tenant + &quot;]: &quot; + uniqueTenants);&#10;            assertTrue(uniqueTenants.contains(tenant),&#10;                    &quot;Database [&quot; + tenant + &quot;] should only contain messages for [&quot; + tenant + &quot;]&quot;);&#10;&#10;            LOG.infov(&quot;✓ Tenant [{0}]: {1} messages validated OK&quot;, tenant, tenantMessages.size());&#10;        }&#10;&#10;        // ── STEP 4: Valida mensagens publicadas na fila de saída ──&#10;        LOG.info(&quot;STEP 4: Validating output queue messages...&quot;);&#10;        Map&lt;String, List&lt;SqsMessageDTO&gt;&gt; outputByTenant = new HashMap&lt;&gt;();&#10;&#10;        // Drena todas as mensagens da fila de saída&#10;        await().atMost(Duration.ofSeconds(30))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .until(() -&gt; {&#10;                    List&lt;Message&gt; outputMsgs = sqsClientService.receiveFromOutputQueue()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    for (Message msg : outputMsgs) {&#10;                        SqsMessageDTO dto = objectMapper.readValue(msg.body(), SqsMessageDTO.class);&#10;                        outputByTenant.computeIfAbsent(dto.getTenantId(), k -&gt; new ArrayList&lt;&gt;()).add(dto);&#10;                    }&#10;&#10;                    int totalOutput = outputByTenant.values().stream().mapToInt(List::size).sum();&#10;                    LOG.infov(&quot;Output queue drained so far: {0}/{1}&quot;, totalOutput, TOTAL_MESSAGES);&#10;                    return totalOutput &gt;= TOTAL_MESSAGES;&#10;                });&#10;&#10;        // Valida que cada tenant tem suas mensagens na fila de saída&#10;        for (String tenant : TENANTS) {&#10;            List&lt;SqsMessageDTO&gt; outputMsgs = outputByTenant.getOrDefault(tenant, List.of());&#10;            assertEquals(MESSAGES_PER_TENANT, outputMsgs.size(),&#10;                    &quot;Output queue should have &quot; + MESSAGES_PER_TENANT + &quot; messages for tenant [&quot; + tenant + &quot;]&quot;);&#10;&#10;            for (SqsMessageDTO dto : outputMsgs) {&#10;                assertEquals(tenant, dto.getTenantId(),&#10;                        &quot;Output message should have correct tenantId&quot;);&#10;                assertTrue(dto.getMessageId().startsWith(&quot;msg-&quot; + tenant),&#10;                        &quot;Output messageId should match tenant&quot;);&#10;            }&#10;&#10;            LOG.infov(&quot;✓ Output queue tenant [{0}]: {1} messages validated OK&quot;, tenant, outputMsgs.size());&#10;        }&#10;&#10;        // ── STEP 5: Verifica que nenhum tenant estranho apareceu ──&#10;        LOG.info(&quot;STEP 5: Verifying no cross-tenant contamination...&quot;);&#10;        Set&lt;String&gt; allTenantsInOutput = outputByTenant.keySet();&#10;        assertEquals(new HashSet&lt;&gt;(TENANTS), allTenantsInOutput,&#10;                &quot;Only expected tenants should appear in output&quot;);&#10;&#10;        LOG.info(&quot;=== MULTI-TENANT CONTEXT PROPAGATION TEST PASSED ===&quot;);&#10;        LOG.infov(&quot;Total messages processed: {0}&quot;, TOTAL_MESSAGES);&#10;        LOG.infov(&quot;Threads used: {0}&quot;, threadsUsed.size());&#10;    }&#10;&#10;    /**&#10;     * TESTE DE CONTEXT PROPAGATION: valida que o TenantContext é propagado corretamente&#10;     * quando mensagens de tenants diferentes são processadas em threads intercaladas.&#10;     */&#10;    @Test&#10;    @Order(2)&#10;    void shouldPropagateContextCorrectlyWithInterleavedTenantMessages() throws Exception {&#10;        LOG.info(&quot;=== STARTING INTERLEAVED CONTEXT PROPAGATION TEST ===&quot;);&#10;&#10;        int messagesPerTenant = 10;&#10;        List&lt;SqsMessageDTO&gt; interleavedMessages = new ArrayList&lt;&gt;();&#10;&#10;        // Intercala mensagens: tenant_a, tenant_b, tenant_c, tenant_a, tenant_b, tenant_c, ...&#10;        for (int i = 0; i &lt; messagesPerTenant; i++) {&#10;            for (String tenant : TENANTS) {&#10;                interleavedMessages.add(new SqsMessageDTO(&#10;                        &quot;interleaved-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Interleaved body &quot; + tenant + &quot; &quot; + i&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Envia todas&#10;        for (SqsMessageDTO dto : interleavedMessages) {&#10;            sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;        }&#10;&#10;        int expectedTotal = messagesPerTenant * TENANTS.size();&#10;&#10;        // Processa — o Context Propagation garante que cada mensagem é processada&#10;        // com o TenantContext correto, mesmo em threads reutilizadas&#10;        await().atMost(Duration.ofSeconds(60))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .untilAsserted(() -&gt; {&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        sqsConsumer.processMessages(messages)&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(15));&#10;                    }&#10;&#10;                    // Conta total em todos os bancos (inclui mensagens do teste anterior)&#10;                    for (String tenant : TENANTS) {&#10;                        List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;                        // Filtra só as deste teste&#10;                        long interleavedCount = msgs.stream()&#10;                                .filter(m -&gt; m.getMessageId().startsWith(&quot;interleaved-&quot; + tenant))&#10;                                .count();&#10;                        assertEquals(messagesPerTenant, (int) interleavedCount,&#10;                                &quot;Tenant [&quot; + tenant + &quot;] should have &quot; + messagesPerTenant + &quot; interleaved messages&quot;);&#10;                    }&#10;                });&#10;&#10;        // Valida integridade: nenhuma mensagem de tenant errado&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;            for (ProcessedMessage pm : msgs) {&#10;                assertEquals(tenant, pm.getTenantId(),&#10;                        &quot;Cross-tenant contamination detected! Message [&quot; + pm.getMessageId()&#10;                                + &quot;] has tenantId [&quot; + pm.getTenantId()&#10;                                + &quot;] but is in database [&quot; + tenant + &quot;]&quot;);&#10;            }&#10;        }&#10;&#10;        LOG.info(&quot;=== INTERLEAVED CONTEXT PROPAGATION TEST PASSED ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * TESTE DE CONCORRÊNCIA MÁXIMA: dispara processamento de múltiplas threads Java&#10;     * simultaneamente para forçar race conditions e validar que o Context Propagation&#10;     * mantém o TenantContext isolado em cada pipeline reativo.&#10;     */&#10;    @Test&#10;    @Order(3)&#10;    void shouldMaintainTenantIsolationUnderHighConcurrency() throws Exception {&#10;        LOG.info(&quot;=== STARTING HIGH CONCURRENCY CONTEXT PROPAGATION TEST ===&quot;);&#10;&#10;        int messagesPerTenant = 20;&#10;        List&lt;SqsMessageDTO&gt; allMessages = new ArrayList&lt;&gt;();&#10;&#10;        for (String tenant : TENANTS) {&#10;            for (int i = 0; i &lt; messagesPerTenant; i++) {&#10;                allMessages.add(new SqsMessageDTO(&#10;                        &quot;concurrent-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Concurrent body &quot; + tenant + &quot; &quot; + i&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Shuffle para máxima mistura de tenants&#10;        Collections.shuffle(allMessages);&#10;&#10;        // Envia todas&#10;        for (SqsMessageDTO dto : allMessages) {&#10;            sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;        }&#10;&#10;        // Processa tudo de uma vez com alta concorrência&#10;        await().atMost(Duration.ofSeconds(90))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .untilAsserted(() -&gt; {&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        sqsConsumer.processMessages(messages)&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(20));&#10;                    }&#10;&#10;                    for (String tenant : TENANTS) {&#10;                        List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;                        long concurrentCount = msgs.stream()&#10;                                .filter(m -&gt; m.getMessageId().startsWith(&quot;concurrent-&quot; + tenant))&#10;                                .count();&#10;                        assertEquals(messagesPerTenant, (int) concurrentCount,&#10;                                &quot;Tenant [&quot; + tenant + &quot;] should have &quot; + messagesPerTenant + &quot; concurrent messages&quot;);&#10;                    }&#10;                });&#10;&#10;        // Valida ZERO cross-tenant contamination&#10;        for (String tenant : TENANTS) {&#10;            List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;            Set&lt;String&gt; tenantIds = msgs.stream()&#10;                    .map(ProcessedMessage::getTenantId)&#10;                    .collect(Collectors.toSet());&#10;&#10;            assertEquals(Set.of(tenant), tenantIds,&#10;                    &quot;Database [&quot; + tenant + &quot;] should ONLY contain tenant [&quot; + tenant&#10;                            + &quot;] but found: &quot; + tenantIds);&#10;&#10;            // Verifica que nenhum messageId de outro tenant acabou neste banco&#10;            for (ProcessedMessage pm : msgs) {&#10;                assertFalse(&#10;                        TENANTS.stream()&#10;                                .filter(t -&gt; !t.equals(tenant))&#10;                                .anyMatch(otherTenant -&gt; pm.getMessageId().contains(otherTenant)),&#10;                        &quot;Message [&quot; + pm.getMessageId() + &quot;] from another tenant found in database [&quot; + tenant + &quot;]&quot;);&#10;            }&#10;        }&#10;&#10;        LOG.info(&quot;=== HIGH CONCURRENCY CONTEXT PROPAGATION TEST PASSED ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * TESTE DE PROPAGAÇÃO DO REPOSITÓRIO: valida que o repositório resolve&#10;     * o tenant corretamente a partir do TenantContext propagado, sem receber&#10;     * tenant como parâmetro.&#10;     */&#10;    @Test&#10;    @Order(4)&#10;    void shouldResolveRepositoryTenantFromPropagatedContext() throws Exception {&#10;        LOG.info(&quot;=== STARTING REPOSITORY CONTEXT PROPAGATION TEST ===&quot;);&#10;&#10;        // Envia algumas mensagens para cada tenant e processa&#10;        int messagesPerTenant = 5;&#10;        for (String tenant : TENANTS) {&#10;            for (int i = 0; i &lt; messagesPerTenant; i++) {&#10;                SqsMessageDTO dto = new SqsMessageDTO(&#10;                        &quot;repo-ctx-&quot; + tenant + &quot;-&quot; + i,&#10;                        tenant,&#10;                        &quot;Repo context test &quot; + tenant + &quot; &quot; + i&#10;                );&#10;                sqsClientService.sendToInputQueue(dto).await().atMost(Duration.ofSeconds(5));&#10;            }&#10;        }&#10;&#10;        // Processa&#10;        await().atMost(Duration.ofSeconds(60))&#10;                .pollInterval(Duration.ofSeconds(1))&#10;                .untilAsserted(() -&gt; {&#10;                    List&lt;Message&gt; messages = sqsClientService.receiveMessages()&#10;                            .await().atMost(Duration.ofSeconds(5));&#10;                    if (messages != null &amp;&amp; !messages.isEmpty()) {&#10;                        sqsConsumer.processMessages(messages)&#10;                                .collect().asList()&#10;                                .await().atMost(Duration.ofSeconds(15));&#10;                    }&#10;&#10;                    for (String tenant : TENANTS) {&#10;                        List&lt;ProcessedMessage&gt; msgs = findMessagesInTenantDb(tenant);&#10;                        long repoCount = msgs.stream()&#10;                                .filter(m -&gt; m.getMessageId().startsWith(&quot;repo-ctx-&quot; + tenant))&#10;                                .count();&#10;                        assertEquals(messagesPerTenant, (int) repoCount,&#10;                                &quot;Tenant [&quot; + tenant + &quot;] should have &quot; + messagesPerTenant + &quot; repo-ctx messages&quot;);&#10;                    }&#10;                });&#10;&#10;        // Agora valida que o repositório resolve o tenant do TenantContext propagado&#10;        // (usando findAllByTenant sem parâmetro — o tenant vem do contexto)&#10;        for (String tenant : TENANTS) {&#10;            TenantContext.setCurrentTenant(tenant);&#10;            try {&#10;                List&lt;ProcessedMessage&gt; repoMessages = repository.findAllByTenant();&#10;                assertFalse(repoMessages.isEmpty(),&#10;                        &quot;Repository should return messages for tenant [&quot; + tenant + &quot;] from propagated context&quot;);&#10;&#10;                for (ProcessedMessage pm : repoMessages) {&#10;                    assertEquals(tenant, pm.getTenantId(),&#10;                            &quot;Repository should only return messages for the propagated tenant [&quot; + tenant + &quot;]&quot;);&#10;                }&#10;&#10;                long repoCtxCount = repoMessages.stream()&#10;                        .filter(m -&gt; m.getMessageId().startsWith(&quot;repo-ctx-&quot; + tenant))&#10;                        .count();&#10;                assertEquals(messagesPerTenant, repoCtxCount,&#10;                        &quot;Repository should find all repo-ctx messages for tenant [&quot; + tenant + &quot;]&quot;);&#10;&#10;                LOG.infov(&quot;✓ Repository context propagation for [{0}]: {1} messages found&quot;, tenant, repoMessages.size());&#10;            } finally {&#10;                TenantContext.clear();&#10;            }&#10;        }&#10;&#10;        // Valida que repositório lança exceção quando TenantContext não está definido&#10;        TenantContext.clear();&#10;        assertThrows(IllegalStateException.class, () -&gt; repository.findAllByTenant(),&#10;                &quot;Repository should throw IllegalStateException when TenantContext is not set&quot;);&#10;&#10;        LOG.info(&quot;=== REPOSITORY CONTEXT PROPAGATION TEST PASSED ===&quot;);&#10;    }&#10;&#10;    // ── Helper methods ──&#10;&#10;    private int countMessagesInTenantDb(String tenantId) {&#10;        String url = String.format(&quot;jdbc:postgresql://%s:%d/%s&quot;, tenantDbHost, tenantDbPort, tenantId);&#10;        try (Connection conn = DriverManager.getConnection(url, tenantDbUser, tenantDbPass);&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&quot;SELECT COUNT(*) FROM processed_message&quot;)) {&#10;            if (rs.next()) {&#10;                return rs.getInt(1);&#10;            }&#10;            return 0;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to count messages in tenant DB &quot; + tenantId, e);&#10;        }&#10;    }&#10;&#10;    private List&lt;ProcessedMessage&gt; findMessagesInTenantDb(String tenantId) {&#10;        String url = String.format(&quot;jdbc:postgresql://%s:%d/%s&quot;, tenantDbHost, tenantDbPort, tenantId);&#10;        List&lt;ProcessedMessage&gt; result = new ArrayList&lt;&gt;();&#10;        try (Connection conn = DriverManager.getConnection(url, tenantDbUser, tenantDbPass);&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&quot;SELECT message_id, body, tenant_id, processed_at, thread_name FROM processed_message&quot;)) {&#10;            while (rs.next()) {&#10;                ProcessedMessage pm = new ProcessedMessage(&#10;                        rs.getString(&quot;message_id&quot;),&#10;                        rs.getString(&quot;body&quot;),&#10;                        rs.getString(&quot;tenant_id&quot;)&#10;                );&#10;                pm.setProcessedAt(rs.getTimestamp(&quot;processed_at&quot;).toInstant());&#10;                pm.setThreadName(rs.getString(&quot;thread_name&quot;));&#10;                result.add(pm);&#10;            }&#10;            return result;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to read messages from tenant DB &quot; + tenantId, e);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>